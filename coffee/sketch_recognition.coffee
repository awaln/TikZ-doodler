drawing = {nodes:{},loners:[],edges:{},nodelabels:{},edgelabels:{}}
node_name_count = 0
loner_name_count = 0
PRETTY_DRAW_COLOR = 'black'
PRETTY_DRAW_SIZE = 2
COMPILE_TO = 'LaTeX'
CLOSED_THRESHOLD = .05
pretty_draw = (ctx, canvas) ->
  ctx.clearRect 0, 0, canvas.width, canvas.height
  for start in Object.keys drawing.edges
    for end in drawing.edges[start]
      ctx.beginPath()
      ctx.moveTo drawing.nodes[start].center_x, drawing.nodes[start].center_y
      ctx.lineTo drawing.nodes[end].center_x, drawing.nodes[end].center_y
      ctx.stroke()
      ctx.closePath()

  for node in Object.keys drawing.nodes
    ctx.beginPath()
    ctx.arc drawing.nodes[node].center_x, drawing.nodes[node].center_y, drawing.nodes[node].radius, 0, 2 * Math.PI
    ctx.fill()
    ctx.stroke()
    ctx.closePath()

  for loner in drawing.loners
    ctx.beginPath()
    ctx.moveTo loner.start[0], loner.start[1]
    ctx.lineTo loner.end[0], loner.end[1]
    ctx.strokeStyle = "red"
    ctx.stroke()
    ctx.strokeStyle = "black"
    ctx.closePath()

  return

@distance_formula = (x1, y1, x2, y2) -> Math.sqrt(Math.pow((x1 - x2),2) + Math.pow(y1 - y2,2))

@recognize = (current_stroke_x, current_stroke_y, ctx, canvas) ->
  # recognize complete stroke and say what you drew
  sketch_size = current_stroke_x.length
  closed = false

  # get how long the stroke is, for math later
  # I might not need this? Keeping it to be safe
  total_stroke_length = 0
  for i in [1...sketch_size]
    total_stroke_length += distance_formula(current_stroke_x[i], current_stroke_y[i], current_stroke_x[i-1], current_stroke_y[i-1])

  # see if it's an open or closed shape
  # call it a closed shape if there is an intersection between [something in 1st quarter] and [something in 4nd quarter]
  for first in [0...Math.floor(sketch_size/4)]
    for last in [Math.floor(sketch_size*3/4)...sketch_size]
      # an intersection is points with euclidean distance within CLOSED_THRESHOLD of the stroke length of each other
      if distance_formula(current_stroke_x[first], current_stroke_y[first], current_stroke_x[last], current_stroke_y[last]) < CLOSED_THRESHOLD * total_stroke_length
        closed = true

  # handle closed shapes
  if closed
    # assume circle center at mean of X and Y
    average_x = current_stroke_x.reduce((total, num) ->
        total + num
      ) / sketch_size
    average_y = current_stroke_y.reduce((total, num) ->
       total + num
      ) / sketch_size
    # radius is average distance to center
    distance = 0
    i = 0
    while i < sketch_size
      distance += Math.sqrt((current_stroke_x[i] - average_x) ** 2 + (current_stroke_y[i] - average_y) ** 2)
      i++
    radius = distance / sketch_size
    drawing['nodes'][node_name_count] =
      name: node_name_count
      type: 'circle'
      center_x: Math.floor average_x
      center_y: Math.floor average_y
      radius: Math.floor radius
    drawing.nodelabels[node_name_count] = "Node " + node_name_count
    node_name_count++

  # handle open shapes (lines)
  else
    # assume straight lines for now
    # type, and two lists of nodes it connects
    drawing['loners'].push
      name: 'Loner ' + loner_name_count
      type: 'line'
      start: [current_stroke_x[0], current_stroke_y[0]]
      end: [current_stroke_x[sketch_size - 1], current_stroke_y[sketch_size - 1]]
    loner_name_count++

  compile COMPILE_TO, drawing
  pretty_draw(ctx, canvas)



# ---
# generated by js2coffee 2.0.3