drawing = {nodes:{},edges:[],relations:[]}
node_name_count = 0
edge_name_count = 0
PRETTY_DRAW_COLOR = 'black'
PRETTY_DRAW_SIZE = 2
COMPILE_TO = 'LaTeX'
CLOSED_THRESHOLD = .05
pretty_draw = (ctx, canvas) ->
  ctx.clearRect 0, 0, canvas.width, canvas.height

  for relation in drawing.relations
    ctx.beginPath()
    ctx.moveTo drawing.nodes[relation.start[0]].center_x, drawing.nodes[relation.start[0]].center_y
    ctx.lineTo drawing.nodes[relation.end[0]].center_x, drawing.nodes[relation.end[0]].center_y
    ctx.stroke()
    ctx.closePath()

  for node in Object.keys drawing.nodes
    ctx.beginPath()
    ctx.arc drawing.nodes[node].center_x, drawing.nodes[node].center_y, drawing.nodes[node].radius, 0, 2 * Math.PI
    ctx.fill()
    ctx.stroke()
    ctx.closePath()

  return

@distance_formula = (x1, y1, x2, y2) -> Math.sqrt(Math.pow((x1 - x2),2) + Math.pow(y1 - y2,2))

# TODO: the drawing should really have nodes, edges, and some category indicating not yet relational edges, but existing in the graph.
@recognize = (current_stroke_x, current_stroke_y, ctx, canvas) ->
  # recognize complete stroke and say what you drew
  sketch_size = current_stroke_x.length
  closed = false

  # get how long the stroke is, for math later
  # I might not need this? Keeping it to be safe
  total_stroke_length = 0
  for i in [1...sketch_size]
    total_stroke_length += distance_formula(current_stroke_x[i], current_stroke_y[i], current_stroke_x[i-1], current_stroke_y[i-1])

  # see if it's an open or closed shape
  # call it a closed shape if there is an intersection between [something in 1st quarter] and [something in 4nd quarter]
  for first in [0...Math.floor(sketch_size/4)]
    for last in [Math.floor(sketch_size*3/4)...sketch_size]
      # an intersection is points with euclidean distance within CLOSED_THRESHOLD of the stroke length of each other
      if distance_formula(current_stroke_x[first], current_stroke_y[first], current_stroke_x[last], current_stroke_y[last]) < CLOSED_THRESHOLD * total_stroke_length
        closed = true

  # handle closed shapes
  if closed
    # assume circle center at mean of X and Y
    average_x = current_stroke_x.reduce((total, num) ->
        total + num
      ) / sketch_size
    average_y = current_stroke_y.reduce((total, num) ->
       total + num
      ) / sketch_size
    # radius is average distance to center
    distance = 0
    i = 0
    while i < sketch_size
      distance += Math.sqrt((current_stroke_x[i] - average_x) ** 2 + (current_stroke_y[i] - average_y) ** 2)
      i++
    radius = distance / sketch_size
    drawing['nodes']['Node ' + node_name_count] =
      name: 'Node ' + node_name_count
      type: 'circle'
      center_x: average_x
      center_y: average_y
      radius: radius
    node_name_count++

  # handle open shapes (lines)
  else
    # assume straight lines for now
    # type, and two lists of nodes it connects
    drawing['edges'].push
      name: 'Edge ' + edge_name_count
      type: 'line'
      start: [current_stroke_x[0], current_stroke_y[0]]
      end: [current_stroke_x[sketch_size - 1], current_stroke_y[sketch_size - 1]]
    edge_name_count++

  compile COMPILE_TO, drawing
  pretty_draw(ctx, canvas)



# ---
# generated by js2coffee 2.0.3