// Generated by CoffeeScript 1.9.1
(function() {
  var CLOSED_THRESHOLD, COMPILE_TO, PRETTY_DRAW_COLOR, PRETTY_DRAW_SIZE, drawing, edge_name_count, node_name_count, pretty_draw;

  drawing = {
    nodes: {},
    edges: [],
    relations: []
  };

  node_name_count = 0;

  edge_name_count = 0;

  PRETTY_DRAW_COLOR = 'black';

  PRETTY_DRAW_SIZE = 2;

  COMPILE_TO = 'LaTeX';

  CLOSED_THRESHOLD = .05;

  pretty_draw = function(ctx, canvas) {
    var j, k, len, len1, node, ref, ref1, relation;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ref = drawing.relations;
    for (j = 0, len = ref.length; j < len; j++) {
      relation = ref[j];
      console.log(relation.start[0]);
      ctx.beginPath();
      ctx.moveTo(drawing.nodes[relation.start[0]].center_x, drawing.nodes[relation.start[0]].center_y);
      ctx.lineTo(drawing.nodes[relation.end[0]].center_x, drawing.nodes[relation.end[0]].center_y);
      ctx.stroke();
      ctx.closePath();
    }
    ref1 = Object.keys(drawing.nodes);
    for (k = 0, len1 = ref1.length; k < len1; k++) {
      node = ref1[k];
      ctx.beginPath();
      ctx.arc(drawing.nodes[node].center_x, drawing.nodes[node].center_y, drawing.nodes[node].radius, 0, 2 * Math.PI);
      ctx.fill();
      ctx.stroke();
      ctx.closePath();
    }
  };

  this.distance_formula = function(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
  };

  this.recognize = function(current_stroke_x, current_stroke_y, ctx, canvas) {
    var average_x, average_y, closed, distance, first, i, j, k, l, last, radius, ref, ref1, ref2, ref3, sketch_size, total_stroke_length;
    sketch_size = current_stroke_x.length;
    closed = false;
    total_stroke_length = 0;
    for (i = j = 1, ref = sketch_size; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
      total_stroke_length += distance_formula(current_stroke_x[i], current_stroke_y[i], current_stroke_x[i - 1], current_stroke_y[i - 1]);
    }
    for (first = k = 0, ref1 = Math.floor(sketch_size / 4); 0 <= ref1 ? k < ref1 : k > ref1; first = 0 <= ref1 ? ++k : --k) {
      for (last = l = ref2 = Math.floor(sketch_size * 3 / 4), ref3 = sketch_size; ref2 <= ref3 ? l < ref3 : l > ref3; last = ref2 <= ref3 ? ++l : --l) {
        if (distance_formula(current_stroke_x[first], current_stroke_y[first], current_stroke_x[last], current_stroke_y[last]) < CLOSED_THRESHOLD * total_stroke_length) {
          closed = true;
        }
      }
    }
    if (closed) {
      average_x = current_stroke_x.reduce(function(total, num) {
        return total + num;
      }) / sketch_size;
      average_y = current_stroke_y.reduce(function(total, num) {
        return total + num;
      }) / sketch_size;
      distance = 0;
      i = 0;
      while (i < sketch_size) {
        distance += Math.sqrt(Math.pow(current_stroke_x[i] - average_x, 2) + Math.pow(current_stroke_y[i] - average_y, 2));
        i++;
      }
      radius = distance / sketch_size;
      drawing['nodes']['Node ' + node_name_count] = {
        name: 'Node ' + node_name_count,
        type: 'circle',
        center_x: average_x,
        center_y: average_y,
        radius: radius
      };
      node_name_count++;
    } else {
      drawing['edges'].push({
        name: 'Edge ' + edge_name_count,
        type: 'line',
        start: [current_stroke_x[0], current_stroke_y[0]],
        end: [current_stroke_x[sketch_size - 1], current_stroke_y[sketch_size - 1]]
      });
      edge_name_count++;
    }
    compile(COMPILE_TO, drawing);
    return pretty_draw(ctx, canvas);
  };

}).call(this);
