// Generated by CoffeeScript 1.9.1
(function() {
  var CLOSED_THRESHOLD, COMPILE_TO, PRETTY_DRAW_COLOR, PRETTY_DRAW_SIZE, count_corners, drawing, loner_name_count, node_name_count, pretty_draw,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  drawing = {
    nodes: {},
    loners: [],
    edges: {},
    arrows: [],
    nodelabels: {},
    edgelabels: {}
  };

  node_name_count = 0;

  loner_name_count = 0;

  PRETTY_DRAW_COLOR = 'black';

  PRETTY_DRAW_SIZE = 2;

  COMPILE_TO = 'LaTeX';

  CLOSED_THRESHOLD = .05;

  pretty_draw = function(ctx, canvas) {
    var end, len, len1, len2, len3, loner, m, midpoint, n, node, o, p, point1, ref, ref1, ref2, ref3, ref4, rise, run, start;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ref = Object.keys(drawing.edges);
    for (m = 0, len = ref.length; m < len; m++) {
      start = ref[m];
      ref1 = drawing.edges[start];
      for (n = 0, len1 = ref1.length; n < len1; n++) {
        end = ref1[n];
        ctx.beginPath();
        ctx.moveTo(drawing.nodes[start].center_x, drawing.nodes[start].center_y);
        ctx.lineTo(drawing.nodes[end].center_x, drawing.nodes[end].center_y);
        ctx.stroke();
        ctx.closePath();
        if (ref2 = start + " " + end, indexOf.call(drawing.arrows, ref2) >= 0) {
          point1 = [drawing.nodes[start].center_x, drawing.nodes[start].center_y];
          rise = drawing.nodes[end].center_y - drawing.nodes[start].center_y;
          run = drawing.nodes[end].center_x - drawing.nodes[start].center_x;
          midpoint = [point1[0] - run * .2, point1[1] - rise * .2];
        }
      }
    }
    ref3 = Object.keys(drawing.nodes);
    for (o = 0, len2 = ref3.length; o < len2; o++) {
      node = ref3[o];
      ctx.beginPath();
      ctx.arc(drawing.nodes[node].center_x, drawing.nodes[node].center_y, drawing.nodes[node].radius, 0, 2 * Math.PI);
      ctx.fill();
      ctx.stroke();
      ctx.closePath();
    }
    ref4 = drawing.loners;
    for (p = 0, len3 = ref4.length; p < len3; p++) {
      loner = ref4[p];
      ctx.beginPath();
      ctx.moveTo(loner.start[0], loner.start[1]);
      ctx.lineTo(loner.end[0], loner.end[1]);
      ctx.strokeStyle = "red";
      ctx.stroke();
      ctx.strokeStyle = "black";
      ctx.closePath();
    }
  };

  this.distance_formula = function(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
  };

  this.recognize = function(current_stroke_x, current_stroke_y, ctx, canvas) {
    var average_x, average_y, closed, corners, distance, first, i, last, m, n, o, radius, ref, ref1, ref2, ref3, sketch_size, total_stroke_length;
    sketch_size = current_stroke_x.length;
    closed = false;
    corners = count_corners(current_stroke_x, current_stroke_y);
    console.log(corners);
    total_stroke_length = 0;
    for (i = m = 1, ref = sketch_size; 1 <= ref ? m < ref : m > ref; i = 1 <= ref ? ++m : --m) {
      total_stroke_length += distance_formula(current_stroke_x[i], current_stroke_y[i], current_stroke_x[i - 1], current_stroke_y[i - 1]);
    }
    for (first = n = 0, ref1 = Math.floor(sketch_size / 4); 0 <= ref1 ? n < ref1 : n > ref1; first = 0 <= ref1 ? ++n : --n) {
      for (last = o = ref2 = Math.floor(sketch_size * 3 / 4), ref3 = sketch_size; ref2 <= ref3 ? o < ref3 : o > ref3; last = ref2 <= ref3 ? ++o : --o) {
        if (distance_formula(current_stroke_x[first], current_stroke_y[first], current_stroke_x[last], current_stroke_y[last]) < CLOSED_THRESHOLD * total_stroke_length) {
          closed = true;
        }
      }
    }
    if (closed) {
      average_x = current_stroke_x.reduce(function(total, num) {
        return total + num;
      }) / sketch_size;
      average_y = current_stroke_y.reduce(function(total, num) {
        return total + num;
      }) / sketch_size;
      distance = 0;
      i = 0;
      while (i < sketch_size) {
        distance += Math.sqrt(Math.pow(current_stroke_x[i] - average_x, 2) + Math.pow(current_stroke_y[i] - average_y, 2));
        i++;
      }
      radius = distance / sketch_size;
      drawing['nodes'][node_name_count] = {
        name: node_name_count,
        type: 'circle',
        center_x: Math.floor(average_x),
        center_y: Math.floor(average_y),
        radius: Math.floor(radius)
      };
      drawing.nodelabels[node_name_count] = "Node " + node_name_count;
      node_name_count++;
    } else {
      if (corners) {
        drawing['loners'].push({
          name: 'Loner ' + loner_name_count,
          type: 'arrow',
          start: [current_stroke_x[0], current_stroke_y[0]],
          end: [current_stroke_x[sketch_size - 1], current_stroke_y[sketch_size - 1]]
        });
      }
      drawing['loners'].push({
        name: 'Loner ' + loner_name_count,
        type: 'line',
        start: [current_stroke_x[0], current_stroke_y[0]],
        end: [current_stroke_x[sketch_size - 1], current_stroke_y[sketch_size - 1]]
      });
      loner_name_count++;
    }
    snap_to(drawing, 10);
    compile(COMPILE_TO, drawing);
    return pretty_draw(ctx, canvas);
  };

  this.snap_to = function(drawing, grid) {
    var len, m, name, node, ref, results;
    ref = Object.keys(drawing.nodes);
    results = [];
    for (m = 0, len = ref.length; m < len; m++) {
      name = ref[m];
      node = drawing.nodes[name];
      if (node.type === "circle") {
        node.center_x = Math.round(node.center_x / grid) * grid;
        node.center_y = Math.round(node.center_y / grid) * grid;
        results.push(node.radius = Math.round(node.radius / grid) * grid);
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  count_corners = function(list_x, list_y) {
    var ARCTAN_THRESHOLD, CURVATURE_THRESHOLD, WINDOW, bottom, corners, corrected_slopes, cum_arc_length, current_wrap, curvatures, i, j, k, l, m, n, number_of_points, o, p, radians, ref, ref1, ref2, ref3, ref4, slope, slopes, top, total_stroke_length;
    WINDOW = 10;
    ARCTAN_THRESHOLD = 1;
    CURVATURE_THRESHOLD = .05;
    number_of_points = list_x.length;
    corners = 0;
    slopes = [0];
    cum_arc_length = [0];
    total_stroke_length = 0;
    for (i = m = 1, ref = number_of_points - 1; 1 <= ref ? m < ref : m > ref; i = 1 <= ref ? ++m : --m) {
      top = Math.min(i + WINDOW, number_of_points - 1);
      bottom = Math.max(0, i - WINDOW);
      slope = (list_y[top] - list_y[bottom]) / (list_x[top] - list_y[bottom]);
      radians = Math.atan(slope);
      slopes.push(radians);
      total_stroke_length += distance_formula(list_x[i - 1], list_y[i - 1], list_x[i], list_y[i]);
      cum_arc_length.push(total_stroke_length);
    }
    slopes[0] = slopes[1];
    slopes[number_of_points - 1] = slopes[number_of_points - 2];
    cum_arc_length.push(total_stroke_length + distance_formula(list_x[number_of_points - 2], list_y[number_of_points - 2], list_x[number_of_points - 1], list_y[number_of_points - i]));
    current_wrap = 0;
    corrected_slopes = [slopes[0]];
    for (j = n = 1, ref1 = number_of_points; 1 <= ref1 ? n < ref1 : n > ref1; j = 1 <= ref1 ? ++n : --n) {
      if (slopes[j - 1] > ARCTAN_THRESHOLD && slopes[j] < -ARCTAN_THRESHOLD) {
        current_wrap++;
      } else if (slopes[j - 1] < -ARCTAN_THRESHOLD && slopes[j] > ARCTAN_THRESHOLD) {
        current_wrap--;
      }
      corrected_slopes.push(slopes[j] + current_wrap * Math.PI);
    }
    curvatures = [0];
    for (k = o = 1, ref2 = number_of_points - 1; 1 <= ref2 ? o < ref2 : o > ref2; k = 1 <= ref2 ? ++o : --o) {
      top = Math.min(k + 1, number_of_points - 1);
      bottom = Math.max(0, k - 1);
      curvatures.push((corrected_slopes[top] - corrected_slopes[bottom]) / (cum_arc_length[top] - cum_arc_length[bottom]));
    }
    curvatures[0] = curvatures[1];
    curvatures[number_of_points - 1] = curvatures[number_of_points - 2];
    for (l = p = ref3 = Math.round(number_of_points / 2), ref4 = number_of_points - 1; ref3 <= ref4 ? p < ref4 : p > ref4; l = ref3 <= ref4 ? ++p : --p) {
      if (curvatures[l - 1] < curvatures[l] && curvatures[l + 1] < curvatures[l] && curvatures[l] > CURVATURE_THRESHOLD) {
        corners++;
      }
    }
    return corners;
  };

}).call(this);
