// Generated by CoffeeScript 1.9.1
(function() {
  var CLOSED_THRESHOLD, COMPILE_TO, PRETTY_DRAW_COLOR, PRETTY_DRAW_SIZE, drawing, loner_name_count, node_name_count, pretty_draw;

  drawing = {
    nodes: {},
    loners: [],
    edges: {},
    nodelabels: {},
    edgelabels: {}
  };

  node_name_count = 0;

  loner_name_count = 0;

  PRETTY_DRAW_COLOR = 'black';

  PRETTY_DRAW_SIZE = 2;

  COMPILE_TO = 'LaTeX';

  CLOSED_THRESHOLD = .05;

  pretty_draw = function(ctx, canvas) {
    var end, j, k, l, len, len1, len2, len3, loner, m, node, ref, ref1, ref2, ref3, start;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ref = Object.keys(drawing.edges);
    for (j = 0, len = ref.length; j < len; j++) {
      start = ref[j];
      ref1 = drawing.edges[start];
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        end = ref1[k];
        ctx.beginPath();
        ctx.moveTo(drawing.nodes[start].center_x, drawing.nodes[start].center_y);
        ctx.lineTo(drawing.nodes[end].center_x, drawing.nodes[end].center_y);
        ctx.stroke();
        ctx.closePath();
      }
    }
    ref2 = Object.keys(drawing.nodes);
    for (l = 0, len2 = ref2.length; l < len2; l++) {
      node = ref2[l];
      ctx.beginPath();
      ctx.arc(drawing.nodes[node].center_x, drawing.nodes[node].center_y, drawing.nodes[node].radius, 0, 2 * Math.PI);
      ctx.fill();
      ctx.stroke();
      ctx.closePath();
    }
    ref3 = drawing.loners;
    for (m = 0, len3 = ref3.length; m < len3; m++) {
      loner = ref3[m];
      ctx.beginPath();
      ctx.moveTo(loner.start[0], loner.start[1]);
      ctx.lineTo(loner.end[0], loner.end[1]);
      ctx.strokeStyle = "red";
      ctx.stroke();
      ctx.strokeStyle = "black";
      ctx.closePath();
    }
  };

  this.distance_formula = function(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
  };

  this.recognize = function(current_stroke_x, current_stroke_y, ctx, canvas) {
    var average_x, average_y, closed, distance, first, i, j, k, l, last, radius, ref, ref1, ref2, ref3, sketch_size, total_stroke_length;
    sketch_size = current_stroke_x.length;
    closed = false;
    total_stroke_length = 0;
    for (i = j = 1, ref = sketch_size; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
      total_stroke_length += distance_formula(current_stroke_x[i], current_stroke_y[i], current_stroke_x[i - 1], current_stroke_y[i - 1]);
    }
    for (first = k = 0, ref1 = Math.floor(sketch_size / 4); 0 <= ref1 ? k < ref1 : k > ref1; first = 0 <= ref1 ? ++k : --k) {
      for (last = l = ref2 = Math.floor(sketch_size * 3 / 4), ref3 = sketch_size; ref2 <= ref3 ? l < ref3 : l > ref3; last = ref2 <= ref3 ? ++l : --l) {
        if (distance_formula(current_stroke_x[first], current_stroke_y[first], current_stroke_x[last], current_stroke_y[last]) < CLOSED_THRESHOLD * total_stroke_length) {
          closed = true;
        }
      }
    }
    if (closed) {
      average_x = current_stroke_x.reduce(function(total, num) {
        return total + num;
      }) / sketch_size;
      average_y = current_stroke_y.reduce(function(total, num) {
        return total + num;
      }) / sketch_size;
      distance = 0;
      i = 0;
      while (i < sketch_size) {
        distance += Math.sqrt(Math.pow(current_stroke_x[i] - average_x, 2) + Math.pow(current_stroke_y[i] - average_y, 2));
        i++;
      }
      radius = distance / sketch_size;
      drawing['nodes'][node_name_count] = {
        name: node_name_count,
        type: 'circle',
        center_x: Math.floor(average_x),
        center_y: Math.floor(average_y),
        radius: Math.floor(radius)
      };
      drawing.nodelabels[node_name_count] = "Node " + node_name_count;
      node_name_count++;
    } else {
      drawing['loners'].push({
        name: 'Loner ' + loner_name_count,
        type: 'line',
        start: [current_stroke_x[0], current_stroke_y[0]],
        end: [current_stroke_x[sketch_size - 1], current_stroke_y[sketch_size - 1]]
      });
      loner_name_count++;
    }
    compile(COMPILE_TO, drawing);
    return pretty_draw(ctx, canvas);
  };

}).call(this);
